#!/bin/sh

prefix=@prefix@
exec_prefix=@exec_prefix@
PATH=@bindir@:@sbindir@:$PATH
export PATH

PROTO=sockets
DBDIR=/tmp/$USER
DBSIZE=$((256 * 1024 * 1024))
LOG_DIR=$HOME
IFACES=default
VNAMES=default
CHFSD=chfsd
DEVDAX=false

program=$(basename $0)

err() {
	[ "X$*" = X ] || echo >&2 $program: $*
	exit 1
}

usage() {
	[ "X$*" = X ] || echo >&2 $program: $*
	echo >&2 "usage: $program [-h hostfile] [-c scratch_dir] [-D] [-m mount_point]"
	echo >&2 "		[-p proto] [-s db_size] [-N vnames] [-I interfaces]"
	echo >&2 "		[-L log_dir] [-S server] [-O options]"
	echo >&2 "		start | stop | status | kill"
	exit 1
}

while [ $# -gt 0 ]; do
	case $1 in
	    start|stop|status|kill) mode=$1 ;;
	    -c) shift; DBDIR=$1 ;;
	    -D) DEVDAX=true ;;
	    -h) shift; HOSTFILE=$1 ;;
	    -I) shift; IFACES="$1" ;;
	    -L) shift; LOG_DIR=$1 ;;
	    -m) shift; MDIR=$1 ;;
	    -N) shift; VNAMES="$1" ;;
	    -O) shift; OPTIONS="$1" ;;
	    -p) shift; PROTO=$1 ;;
	    -s) shift; DBSIZE=$1 ;;
	    -S) shift; SERVER=$1 ;;
	    -*) echo "unknown option: $1"
		usage ;;
	    *) usage ;;
	esac
	shift
done

[ "X$mode" = X ] && usage
[ "X$HOSTFILE" != X ] &&
	[ ! -f $HOSTFILE ] && usage $HOSTFILE: no such file
[ "X$IFACES" = X ] && usage
[ -d "$LOG_DIR" ] || mkdir -p "$LOG_DIR"
[ -d "$LOG_DIR" ] || err $LOG_DIR: no such directory

PKILL_FLAG=
[ "$mode" = kill ] && PKILL_FLAG=-9
NO_SERVER=false
[ "X$SERVER" = X ] && NO_SERVER=true
HOSTS=
[ "X$HOSTFILE" = X ] ||
	HOSTS="$(sed -e 's/#.*//' -e '/^[ 	]*$/d' $HOSTFILE | awk '{ print $1 }')"

CHFS_OPTIONS="-p $PROTO -s $DBSIZE $OPTIONS"
SERVER_INFO_FILE=/tmp/server-info-file-$USER
MYHOSTNAMES="$(hostname) $(hostname -f) $(hostname -A) $(hostname -I)"

stop_chfs() {
	rm -f $SERVER_INFO_FILE

	if [ "X$HOSTS" = X ]; then
		pkill $PKILL_FLAG $CHFSD
		[ X"$MDIR" != X ] && fusermount -u "$MDIR"
	fi
	p=0
	MAX_JOBS=8
	for host in $HOSTS
	do
		ssh $host pkill $PKILL_FLAG $CHFSD &
		if [ X"$MDIR" != X ]; then
			ssh $host fusermount -u "$MDIR" &
		fi

		p=$((p + 1))
		if [ $p -ge $MAX_JOBS ]; then
			p=0
			wait
		fi
	done
	wait
}

status_chfs() {
	if ! $NO_SERVER; then
		chlist "$SERVER"
	elif [ -s $SERVER_INFO_FILE ]; then
		chlist $(cat $SERVER_INFO_FILE)
	else
		echo >&2 no server info file
	fi

	if [ "X$HOSTS" = X ]; then
		echo $(hostname -f)
		ps -ef | grep $CHFSD | egrep -v grep
		[ X"$MDIR" != X ] && ps -ef | grep chfuse | egrep -v grep
	fi
	for host in $HOSTS
	do
		echo $host
		ssh $host "ps -ef | grep $CHFSD | egrep -v grep"
		if [ X"$MDIR" != X ]; then
			ssh $host "ps -ef | grep chfuse | egrep -v grep"
		fi
	done
}

start_chfs() {
nservers=0
START_LOCAL_SERVERS=false
if $NO_SERVER; then
	rm -f $SERVER_INFO_FILE
	SERVER="-S $SERVER_INFO_FILE"

for name in $VNAMES; do
	[ $name = default ] || NOPT="-n $name"
for device in $IFACES; do
	[ $device = default ] || HOPT="-h $device"
	if $DEVDAX; then COPT="-c $DBDIR"; else COPT="-c $DBDIR/$device-$name"; fi
	LOPT="-l $LOG_DIR/$(hostname)-$device-$name"
	$CHFSD $CHFS_OPTIONS $COPT $LOPT $HOPT $NOPT "$SERVER"
	nservers=$((nservers + 1))

	if $NO_SERVER; then
		timeout=10
		while [ ! -s $SERVER_INFO_FILE -a $timeout -gt 0 ]; do sleep 1; timeout=$((timeout - 1)); done
		[ $timeout -eq 0 ] && err $CHFSD: timeout

		SERVER=`cat $SERVER_INFO_FILE`
		[ X"$SERVER" = X ] && err $CHFSD: no server info
		NO_SERVER=false
	else
		# XXX
		sleep 1
	fi
	HOPT=
done
	NOPT=
done
START_LOCAL_SERVERS=true
fi
echo "CHFS_SERVER=\"$SERVER\"; export CHFS_SERVER"
CHFS_SERVER="$SERVER"; export CHFS_SERVER

SERVERS="$(chlist | awk '{ print $1 }')"
[ "X$SERVERS" = X ] && err chlist: no server
set $SERVERS
MAX_JOBS=$#

p=0
for host in $HOSTS
do
	if $START_LOCAL_SERVERS; then
		echo $MYHOSTNAMES | grep $host > /dev/null && continue
	fi
	for name in $VNAMES; do
		[ $name = default ] || NOPT="-n $name"
	for device in $IFACES; do
		[ $device = default ] || HOPT="-h $device"
		if $DEVDAX; then COPT="-c $DBDIR"; else COPT="-c $DBDIR/$device-$name"; fi
		LOPT="-l $LOG_DIR/$host-$device-$name"
		ssh $host LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" PATH=\"$PATH\" $CHFSD $CHFS_OPTIONS $COPT $LOPT $HOPT $NOPT \"$1\" &
		nservers=$((nservers + 1))
		shift
		HOPT=
		p=$((p + 1))
		if [ $p -ge $MAX_JOBS ]; then
			p=0
			wait
			set $(chlist | awk '{ print $1 }')
			MAX_JOBS=$#
		fi
	done
		NOPT=
	done

	p=$((p + 1))
	if [ $p -ge $MAX_JOBS ]; then
		p=0
		wait

		set $(chlist | awk '{ print $1 }')
		MAX_JOBS=$#
	fi
done
wait
if [ X"$MDIR" != X ]; then
	timeout=10
	while [ $timeout -gt 0 -a $(chlist | wc -l) -lt $nservers ]; do
		timeout=$((timeout - 1))
		sleep 1;
	done
	if [ $(chlist | wc -l) -lt $nservers ]; then
		echo >&2 "$program: timeout, $(chlist | wc -l) of $nservers servers are running.  you may need chmkdir $MDIR manually"
	fi
	chmkdir "$MDIR" > /dev/null 2>&1 || :

	if [ "X$HOSTS" = X ]; then
		mkdir -p "$MDIR"
		chfuse -o direct_io,modules=subdir,subdir="$MDIR" "$MDIR"
	fi
	for host in $HOSTS
	do
		ssh $host mkdir -p "$MDIR"
		ssh $host LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" PATH=\"$PATH\" CHFS_SERVER=\"$CHFS_SERVER\" CHFS_LOG_PRIORITY=$CHFS_LOG_PRIORITY CHFS_CHUNK_SIZE=$CHFS_CHUNK_SIZE CHFS_RDMA_THRESH=$CHFS_RDMA_THRESH CHFS_RPC_TIMEOUT_MSEC=$CHFS_RPC_TIMEOUT_MSEC CHFS_NODE_LIST_CACHE_TIMEOUT=$CHFS_NODE_LIST_CACHE_TIMEOUT chfuse -o direct_io,modules=subdir,subdir="$MDIR" "$MDIR"
	done
fi
}

case $mode in
start)
	start_chfs ;;
stop|kill)
	stop_chfs ;;
status)
	status_chfs ;;
*)
	usage ;;
esac

exit 0
